# 计算机系统4-> 计组与体系结构1 | 基础概念与系统评估

在大二上学期学习数字逻辑的过程中，我对计算机如何运作产生了兴趣，因此开了这个系列来记录自己在这方面的学习过程，此前三篇分别是：

1. [计算机系统->Hello World的一生 | 程序如何运行](https://www.cnblogs.com/Roboduster/p/15612880.html)，从大致过程上介绍了一个简单的Hello World程序是如何被计算机实现的
2. [计算机系统2->从芯片说起 | 芯片怎样诞生](https://www.cnblogs.com/Roboduster/p/15750842.html)是我在学习另一本书以及B站学习的时候的知识总结，主要讲解数字逻辑层和半导体物理层之间的联系。
3. [计算机系统3-> 现代计算机基石 | 图灵机理论](https://www.cnblogs.com/Roboduster/p/15772636.html)，同样十一篇读书笔记，附上了自己的思考。这是计算机能够成立的理论基础。

> 本来嘛，按照这个系列的节奏，下一篇就是冯诺依曼结构或者是CPU的内部结构（事实上CPU的内部结构与原理已经在学了来着），再下一篇可能还会讲讲信息论，但这学期开了一门专业课叫做计算机组成原理与体系结构，正好就是在讲这方面的知识，因此接下来我会结合课本和此前读的书进行系列的更新。并将实践CPU的记录也更新到这个系列中来。

今天这篇主要总结课本第一章的内容，即计算机组成与体系结构的基础概念，比如计算机科学、设计思想、程序、硬件结构、性能评估等。本文可能有很多生词，我尽力给出合理的批注。实际上其中很多东西大学计算机基础可能都讲了，但不幸，我们学院是没有要求这门基础课的（取而代之的是机械制图）。

写的有点多，很多是对知识的复述，后续我会对文章进行精简，系列后面也会注意。

参考资料：

1. Computer Organization and Design the 5th Edition，即计算机组成与设计硬件软件接口第五版
2. 课件，由于是英文且只是老师的思路，所以是辅助参考

## 00  一些前言

### 00-1  这门课的重要性

作为一个计算机系的学生，从学科素养上讲，如果四年学习下来，不了解DRAM、流水线、多级缓存、I/O接口、虚拟内存这些概念，实在是说不过去，从日常生活上讲，学了计算机还不懂得如何选购一台性能较佳的电脑，也说不过去。

此外，这部分内容对于以后想要从事芯片设计、编译器开发、操作系统设计等底层方向的同学是十分重要的。就算不从事这些方面，只从事软件开发，这部分内容也会让你对于优化程序或项目和bug调试有更深的理解，对于特定的APP可以选用合适的硬件。

举个例子，如果我们要进行一个大型的矩阵乘法运算，我们应用这门课的知识，就可以对其进行较深层次的优化，使其性能提高200倍：

1. 采用数据级并行DLP（SIMD)，在第三章中学到。性能提高3.8倍；
2. 采用指令级并行ILP，循环展开开发多指令发射、乱序执行硬件，第四章。性能提高2.3倍；
3. 内存以及cache的存储器层次优化，第五章。2.5倍；
4. 线程级并行，在多核上并行循环，第六章。14倍；

在课程学习开始前，还可以先思考**几个问题**：

1. 如何评估一个程序的性能？如何改进程序性能？
2. 什么是软硬件之间的接口？软件如何指导硬件完成工作？
3. 如何进行内存管理：数据是怎么被放置的，放置在哪里？
4. 如何进行线程管理：如何写一个多线程的程序？
5. 从硬件的角度讲，哪些操作实现容易或者快一点？

如果无法理解这些问题，决定优劣与否，就会堕入反复实验的复杂过程，反之，则是一个深入分析的科学过程。

### 00-2  关于计算机科学

计算机科学的发展简史我就略过了，没啥意思。回头有空单出一篇这个文。

#### 00-2-1  有关 IT | 信息科学

IT（Inforamation Technology）是信息理论和计算理论的结合，两者共同奠基和定义了信息科学，信息理论方面有香农的信息论（采集定理），计算理论即图灵机和冯-诺伊曼结构。我们学习的计算机科学与技术偏向于计算理论，信息理论主要是电子信息方面在学习。

![image-20220303103257387](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220303103257387.png)

当然，有机会我会了解一些信息方面的知识。

#### 00-2-2  计算机应用分类

1. 个人电脑

   强调对个人提供良好性能，价格较低，可运行第三方软件。

   一般有4-12个CPU（**中央处理单元Central Process Unit**），内存在GB级（也有TB级的）

2. 服务器

   用于运行大型程序的计算机，可以支持多用户的并行使用，一般通过网络访问。

   高端服务器称为超级计算机，一般由海量处理器组成（上百万CPU），内存为TB级，能耗很大但很高效；用于高端科学和工程计算。

   ![image-20220303105748472](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220303105748472.png)

   注意这里的Gb和GB并不相同，1Gb(gigabit) == 156MB。

3. 嵌入式计算机

   即嵌入到其他设备里的计算机，运行预先设置好的一个或一组应用程序，是数量最多的一类计算机，用于如汽车、电视等的微处理器和处理器网络；

   通常程序和硬件集成在一起，一起交付给用户。此类计算机关键在于可靠性、低成本和低功耗。

   许多嵌入式处理器使用处理器核，处理器核就是利用硬件描述语言（比如Verilog）描述的处理器版本，这样设计者就能把处理器和其他硬件集成在一块芯片上。

#### 00-2-3  后PC时代

1. 个人移动设备（Personal Mobile Device PMD）

   包括手机、平板、智能手表、甚至智能眼镜；电池供电，下载软件app进行功能实现，无键盘鼠标，采用触摸屏以及语音作为输入。

2. 云计算

   替代传统服务器，依赖于仓储规模计算机的巨型数据中心(Warehouse Scale Computer WSC)，在网络上提供服务的大服务器集群，运营商根据需求出租一部分为PMD提供软件服务。典型例子是Web搜索和社交网络。

   PMD / WSC是硬件工业的革命，通过云计算实现的**软件即服务**是软件工业的革命。

### 00-3  通用计算机结构

这个课程主要研究的是通用计算机的基本结构与组成，我们每一章都会学习一部分，下图是一个概要，后面硬件概念的部分还会提到：

![image-20220303173138675](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220303173138675.png)

当然，讲到通用计算机结构，离不开冯·诺伊曼结构：

1. 存储器 / 内存Memory：存储信息（数据/程序）
2. 运算器：计算、处理信息
3. 输入设备：把信息放入电脑的途径
4. 输出设备：电脑输出信息的途径
5. 控制器：确保以上各个部分在正确的时间正确地执行它们的任务

![img](https://pic4.zhimg.com/80/v2-f36df5ca2785645c05c438ed3df0ad4f_720w.jpg)

### 00-4  理解程序性能

此前写的本系列的第一篇：《程序是如何运行的》是很浅薄的，正如前面提到的学习这门课的重要性那部分所提到的例子，程序性能的理解是贯穿这个课程的核心问题之一。

程序的性能取决于：

| 软/硬件组成                | 如何影响性能                             | 知识坐标       |
| -------------------------- | ---------------------------------------- | -------------- |
| 算法                       | 决定了源码级语句的数量和I/O操作数量      | 算法与数据结构 |
| 编程语言、编译器和体系结构 | 决定了每条源码级语句对应的计算机指令数量 | 本书第2、3章   |
| 处理器和存储系统           | 决定了指令的执行速度                     | 第4、5、6章    |
| I/O系统                    | 决定了I/O操作可能的执行速度              | 第4、5、6章    |

人类对于性能的要求是没有上限的，新的算法、新的应用、新的概念、对制造工艺进行改进、对计算机体系结构进行改进等

## 01  计算机系统结构中的8个伟大思想

1. 面向摩尔定律的设计

   即单芯片上的集成度每18~24月翻一番，计算机设计者必须预测设计完成时的工艺水平，而不是设计开始时的。

   同时DRAM（动态随机存取存储器）是两年翻一番，处理器是1.5年翻一番（这个在变慢，磁盘disk是一年翻一番

2. 抽象简化设计(abstraction)

   用抽象表示不同的设计层次，在高层次中忽略低层次的细节。抽象层次中的关键接口是指令级体系结构，这点在后面会继续提到，这时硬件和底层软件的接口。

3. 加速大概率事件(common case fast)

   大概率事件通常比较简单，所以易于提高性能。

4. 通过并行提高性能(parallel performance)

   前面也提到了，会学到很多并行操作来提高性能。

5. 通过流水线提高性能(pipelining)

   流水线是一个特别的并行性场景，可以理解为一个水管，每一个模块是其中的一个管子。

6. 通过预测提高性能(prediction)

   “求人准许不如求人原谅”，即假定从错误预测恢复的代价不高并且预测的准确率相对比较高，那么就可以通过预测的方式提前开始某些操作，这肯定比得到相关指令再启动要快。

7. 存储器层次(hierarchy of memory)

   存储器的速度影响性能，存储器的容量限制了解题的规模，而当今计算机系统中存储器的cost占了主要部分。所以存储器的设计追求速度更快、容量更大、价格更便宜。设计者们的办法之一就是设计存储器层次：

   速度最快、容量最小（同时价格也最昂贵）的存储器位于顶层，用于及时取放数据，而速度最慢、容量最大的存储其位于最底层。就像一个三角塔一样。

   而这样设计，从外部以程序员的视角看来，就实现了存储器高速度、大容量且便宜的整体特征。

8. 通过冗余提高可靠性

   计算机的可靠性可以通过使用冗余部件的方式提高。就像远行的汽车带着的备胎，当轮胎出问题时，更换后可以继续工作。

## 02  程序概念入门

> 这部分是对该系列第一篇[计算机系统->Hello World的一生 | 程序如何运行](https://www.cnblogs.com/Roboduster/p/15612880.html)的复习与深化。

### 02-1  系统软件

计算机硬件只能执行很简单的低级指令，我们编写的应用程序到这些低级指令之间，需要通过**多个软件层次（系统软件）**将高层次的语句操作逐层解释/翻译为简单的计算机指令。这可以算作01部分抽象思想的一个体现。

![image-20220303153630506](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220303153630506.png)

如上图所示，外层是应用软件，在其与中心——硬件之间有一层系统软件。**系统软件是提供常用服务的软件**，包括操作系统、编译程序、加载程序、汇编程序等。

其中，**操作系统**和**编译程序**对于现代计算机是必要的。

- **操作系统**是为了让程序更好地在计算机上运行而管理计算机资源的监控程序。是用户程序与硬件之间的接口，为用户提供各种基础服务和监控功能，最重要的功能如下：

  1. 处理基本的输入输出操作；
  2. 分配外存和内存；
  3. 为多个应用程序提供共享计算机资源的服务；

  常见的操作系统有Windows，Linux，iOS等。

  在操作系统中，封装了I/O操作、存储器分配和其他低级的系统功能细节，使得程序员不需要再过多注意这些琐碎的细节。

- **编译程序**将高级程序语言如C++、Java等写成的程序翻译成硬件能够执行的指令。

### 02-2  从高级语言到硬件语言

要想控制底层的电子硬件，就要描述电子硬件的状态：通、断。计算机中用1、0来描述。因此计算机语言是二进制数，每个字符就是二进制数字中的一个二进制位 / **一位(bit)**，

我们对计算机的命令就是**指令**，即能被计算机识别、理解并执行的命令位串，比如1000110010100000，表示两个数相加。可见这串数字既描述了指令，又描述了数据。这是计算机的基础。

最开始，程序员就是通过二进制将指令传达给计算机的，但这很难，后来发明了助记符，手工比对二进制，但依然繁琐；随后设计人员就开发了被称为**汇编程序**的软件，**可以将助记符自动翻译为对应的二进制**。比如写下：

```
add A,B
```

汇编程序就会将该符号翻译为表示两数相加的机器指令

```
1000110010100000
```

上面的助记符所代表的符号语言今天仍然在使用，即**汇编语言**，而机器能够理解的二进制语言被称为**机器语言**。

虽然这已经是一个巨大的进步，但依然与人工演算的符号相差很多，并且需要程序员完全像计算机一样思考。

于是更进一步的抽象诞生了**高级编程语言及其编译语言**，大大提高了软件生产率。下图是这些程序与编程语言的关系图：

![image-20220303171959236](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220303171959236.png)

可以看到，C语言经过编译编程汇编语言程序，再经过汇编变为机器语言。

> 留意一下，这里的转变都是软件层面的。

编译程序的出现，使得程序员可以写

```
A+B
```

来表示

```
add A,B
```

编译程序会自动实现前者向后者的转换。这样做好处显然多多，解放了程序员的思考难度、提高了生产效率、提高了程序相对于计算机的独立性。

### 02-3  关于（指令集）体系结构

讲到这里，我们可能还是不明白课程名字中的体系结构是什么意思，与组成原理又有什么不同呢，我此前一直认为组原是指概念，而体系结构是组成计算机的硬件，实际上：

**计算机体系结构（architecture） = 指令集（ISA）+ 计算机组成（microarchitecture）**

为什么放在这里讲而不是前言，是因为指令级体系结构使用了抽象的设计思想，是最重要的抽象之一，也是程序从高级到底层中的关键一环。

**计算机体系结构的存在可以让设计者讨论更宏观的设计方法，而不需要考虑硬件电路的状态**；这一抽象层分开了我们解决问题的软件思路和硬件电路的具体实现，就比如我们写出一个时钟程序，实现计时、显示时间、设置闹钟等功能，就不必考虑底层的LED、时钟控制电路等。体系结构在计算机系统的层次如下：

![image-20220305100141679](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220305100141679.png)

自下而上，依次为电子管 -> 电路 -> 数字逻辑 / 硬件逻辑 -> 微体系结构 -> 指令级体系结构 -> 运行时系统（操作系统级）-> 程序语言 -> 算法 -> 问题。同时这也展示了计算机系统中的抽象层次；

指令级体系结构就在ISA那一层，负责软件向硬件的过渡。

![image-20220305102604071](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220305102604071.png)

> 微体系结构也称微处理器体系结构，是在计算机工程中，将一种给定的 **指令集架构** 在 **处理器** 中执行的方法。
>
> 运行时系统的作用与操作系统相似，主要是进行内存管理和任务调度等。
>
> 提供给程序员的基本指令及和操作系统接口合称为**应用二进制接口**（Application Binary Interface ABI)

回忆前文，程序从软件再向下到硬件描述，就要通过体系结构（指令集和微体系结构）的对机器语言的翻译规范、以及特定处理器实现向硬件指令和数据的转化：

![image-20220305110318399](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220305110318399.png)

![image-20220305115716768](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220305115716768.png)

> 有没有过这么一个问题，即组成原理和体系结构有什么区别？以下参考了[这篇博客](https://blog.csdn.net/qq_42146775/article/details/105477073)以及老师的课件：
>
> 举个例子：
>
> 1. 一台机器是否具备乘法指令的功能，这是计算机体系结构的问题；
> 2. 如何实现这个乘法指令的，使用专门的乘法电路还是采用连续相加的加法电路等，这是计算机组成的问题
>
>
> **日常生活的应用**
>
> 许多计算机厂商向用户提供一系列体系结构相同（实现逻辑）的计算机，而它们的组成（具体排布、实现方式）却有很大的差异，因此只知道结构不知道组成是选不好适合的电脑的
>
> **专业一点的说**
>
> 计算机体系结构是指那些能够被程序员所见到的计算机属性。所看到的计算机属性，包括指令集、数据类型、存储器寻址技术、I/O机理等（抽象，概念性）
>
> 比如IBM PC和 RS6000 是具有不同的指令集、数据类型、存储器寻址技术、I/O机理，所以这两种机器的结构各不相同。
>
> 从体系结构出发解决问题更像是一个**建筑设计师**；
>
> 计算机组成就是如何具体实现这些计算机结构所体现的属性，比如硬件细节，指令集体现了机器的属性，这是结构问题。但指令的实现，比如如何取指令、分析指令、取操作数等等，这些都是计算机组成问题；
>
> 从组成原理出发解决问题更像是一个**建筑（土木）工程师**；

## 03  ⭐硬件概念入门 | 冯·诺依曼体系结构

每台计算机的硬件都要完成相同的几个基本功能：

1. 输入数据
2. 输出数据
3. 处理数据
4. 存储数据

即计算机是由完成输入、输出、处理、存储数据任务的部件组成的，具体讲有五个部件：输入、输出、存储器、数据通路（运算器）、控制器。这也是冯·诺依曼结构的体现。

> 处理器从逻辑上包括了数据通路和控制器。前者负责算数运算，后者负责指导数据通路、存储器和I/O设备按照程序指令正确执行。
>
> 处理器是计算机中最活跃的部分，有时人们也把处理器称为中央处理单元，即CPU；

![image-20220303173138675](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220303173138675.png)

![img](https://pic4.zhimg.com/80/v2-f36df5ca2785645c05c438ed3df0ad4f_720w.jpg)

### 03-1  一些实物结构

不同的计算机设备的内部模块安排不尽相同，我们可以从其拆卸外壳后的结构排布大致看出一些设计思想与理念。这部分只能是列举一些，进一步感兴趣可以看一些拆解记录和拆解视频。

#### 03-1-1  iPad Air 2逻辑主板

![image-20220304155243831](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220304155243831.png)

- 红色圈中是一个苹果APL1012 A8X 64位处理器，
- 橘色尔必达/美光q科技的F8164A3MD的2Gb内存，
- 黄色是SK海力士H2JTDG8UD1BMR的 128Gb（16GB）NAND闪存
- 绿色：NXP 65V10 NFC模组（同iPhone 6/iPhone 6 Plus所用相同）
- 蓝色是苹果（Cirrus Logic） 338S1213音频解码器，
- 紫色是ARM Cortex-M3微控制器（苹果M8协处理器）；
- 黑色是Murata 339S02541 Wi-Fi模组。

#### 03-1-2  奔腾四处理器

一般给出下面两个图，我们就能了解一个硬件内部的结构和组成。

![image-20220304160908773](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220304160908773.png)

可以看到组成原理图中左上角的是多级内存模块，右上角是数字和逻辑处理单元、左下角是前台（解码器、缓存器trace cache、分支预测等）、右下角是乱序执行单元。每个框图里分别是内部的一些逻辑结构。

![image-20220304160936926](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220304160936926.png)

这个是系统结构图，更加接近硬件的真实情况。

### 03-2  输入设备和输出设备

这部分会在**第五第六章**讲解，现在介绍一些基本硬件。

#### 03-2-1  显示器

图形显示器无疑是最有人气的I/O设备，PMD大多使用轻巧、低功耗的液晶显示(Liquid Crystal Display LCD)，LCD不是光源，而是利用液晶的光学原理控制光的传输。

大多数LCD显示器采用动态矩阵显示(active matrix display)，每一个像素都由一个晶体管控制电流，这样使图像更清晰。而彩色动态矩阵LCD中，还有一个红-绿-蓝屏决定三种颜色分量的强度，这时每个像素点需要3个晶体管控制。

> 1. 像素：图像元素的最小单元；
>
> 2. 图像由像素矩阵组成，可以表示为二进制位的矩阵（位图bit map），矩阵的大小反映了屏幕的尺寸以及分辨率，彩色显示器用8位标识每个三原色，每个像素就是24位。
>
>    这一点我此前在拓展数字逻辑课程知识的时候，用FPGA+VGA显示矩阵色彩的时候接触过，但没有及时总结，预计数字逻辑实践系列后续会总结这个过程。
>
> 3. 动态矩阵显示：液晶显示技术；

#### 03-2-2  触摸屏

PC使用LCD显示屏，而后PC的平板和智能手机使用触摸屏进一步替代了键盘和鼠标，用户体验得到了很大的提升。

### 03-3  处理器

这部分会在第四章讲解。

处理器从逻辑上包括两个部分：数据通路和控制器。分别相当于处理器 的肌肉和大脑，

![image-20220305090239405](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220305090239405.png)

上图是一个苹果A5的处理器集成电路结构图。芯片尺寸位12.1mm×10.1mm，采用45nm工艺，中间靠左侧的是两个ARM处理器，左上角是有4个数据通路的图形处理器单元(GPU Graphic Processor Unit)；左下角以及底部是与主存的接口。

处理器目前的发展趋势是向多核处理器转变，这就是并行性革命的发展。多核处理器的意思就是再同一块微处理器中加入多个处理器，增加处理事务的速度（单位时间内完成的任务数，吞吐率）。

我们所说的四核微处理器，其实就是有四个处理器的微处理器、或是四个core的芯片。

> 后续有机会，我会进一步了解**并行编程**。

### 03-4  存储器

03-1-1的iPad Air2的主板介绍中提到了两个存储器芯片，每块容量1Gb也就是156MB。

内存是程序运行时的存储空间，同时也保存程序运行时使用的数据。内存由多片DRAM芯片组成（DRAM：动态随机访问存储器 dynamic random access memory），用来承载程序的指令和数据。

DRAM的特点是无论数据存储在什么位置，访问的时间基本一致。这一点与串行访问内存的磁带不同。

提到存储器，其实03-3中的处理器内部也使用一种存储器，即缓存（cache memory），它的特点是小而快，作为连接高速处理器和较低速内存的一个缓冲区。这一点前面八大思想中也有提及。

cache采用的是另一种存储技术：静态随机访问存储器SRAM，速度更快，价格高一点。

> 缓存和内存（也是主存）是存储器层次中的两层。接下来一节会完整介绍存储器的全部层次：

### 03-5  数据存储安全

前面提到的内存是易失性存储器（比如DVD，关掉电源，记录内容不会丢失，DVD采用的是非易失性存储器），我们需要解决计算机数据在关掉电源之后的存储。

对于易失性存储器和非易失性存储器，前者也称主存（DRAM技术），后者也称**二级存储器**，这是继前文的缓存、内存下更低的一层，**用来保存两次运行之间的程序和数据**。我们平时叫的**磁盘（magnetic disk）**，就是二级存储器的一种。

目前PMD中**闪存（flash memory）**使用的更多：

- 闪存比DRAM更慢、价格便宜很多，但要比磁盘高一点；
- 但是闪存在体积、电容、可靠性和能耗方面都比磁盘优秀；
- 但是，闪存在写入100000~1000000次后会老化或损坏；
- 所以相应的，使用闪存的文件系统需要记录写入操作的数目，并考虑避免存储器损坏的办法。

### 03-6  计算机间通信

计算机除了上面提到的功能，还需要与其他计算机通信，即计算机网络功能。

联网的计算机有以下优点：

1. 通信：计算机之间高速交换信息；
2. 资源共享：有些I/O设备可以由网络上的计算机共享，而不必每台计算机都有；
3. 远距离访问：在很远的地方通过别的设备访问计算机。

网络类型：

- 以太网
  - 最常见的网络类型，传输距离长（1000千米）、传输速率高（40Gbps），可以将同一层楼的计算机连接起来，这就是局域网的一个例子。
  - 局域网是在一个小的局部地区使用的传输数据的网络。
  - 局域网通过交换机连接，可以提供路由和安全服务。
- 广域网
  - 支持万维网，以光纤为基础像通信公司租用。
  - 将区域扩展到几百千米范围的网络。

## 04  性能

好了，下面我们终于要来探讨一些与买电脑有关一点的事情了。这也是本文最后的实质性内容。

### 04-1  性能的定义与衡量

在评价性能之前，我们需要给出性能的评价标准，是否计算机速度快就是好呢？恐怕也不尽然。对于性能，我们有很多描述方法，用于在不同情境下的性能衡量。下面这些是有关性能的一些名词。

- 响应时间
  - 计算机完成某任务所需要的全部时间，包括硬盘访问、内存访问、I/O活动、操作系统开销以及CPU执行时间；
  - 对于普通用户以及PMD而言，响应时间可能最重要，这会影响工作性能或者游戏体验；
- 吞吐率
  - 也叫带宽，表示单位时间内完成的任务数；
  - 而对于服务器，会更注重吞吐率。
- 二者关系
  - 降低响应时间，基本上就会增加带宽；
  - 采用多处理器分别处理独立任务，只能增加带宽。
- 性能
  - 性能 = 1 / 响应时间
  - 此后在前几篇子系列文中，会着重讨论**响应时间代表的性能**，但本文会讨论另一个概念：
- CPU时间
  - 但问题很明显，同一个处理器上并不是只运行一个任务，我们要把运行自己任务的时间和一般的响应时间区别开来；
  - CPU（执行）时间就只表示在CPU上花费的时间，不包括I/O操作等；
  - 当然，我们感受到的还是响应时间，而不是CPU时间；
  - CPU时间进一步划分：
    - ·CPU用于用户程序的时间：用户CPU时间；
    - 操作系统为用户服务花费的CPU时间：系统CPU时间；
  - 相应地：
    - **CPU性能**描述用户CPU时间；
    - **系统性能**描述空载系统的响应时间；
  - 计算机性能既可以指响应时间度量，也适用于CPU时间的度量；
  - 下面我们讨论的重点就是**CPU性能**，**响应时间的度量**会放在后面讲；

### 04-2  CPU的性能

CPU性能是用户和设计者都看重的性能。

- 公式一：一个程序的CPU执行时间 = 一个程序的CPU时钟周期数 × 时钟周期时间
- 公式二：一个程序的CPU执行时间 = 一个程序的CPU时钟周期数 / 时钟频率

由以上式子可知，减少等号右侧物理量，就可以改进性能，但这种改进并不容易。有时减少时钟周期数还会引起时钟周期时间的增加。

> 虽然目前电脑会有不同的时钟频率，但我们还是使用一个平均值来做。

### 04-3  指令的性能

继续对上面的公式进行考量，我们可以对时钟周期数进行细分，执行任务的是程序，而运行程序的基本单元是指令，所以可以有：

- 公式三：CPU时钟周期数 = 程序指令数 × CPI

> - CPI表示执行每条指令所需的时钟周期数的平均值；同时IPC是它的倒数(instruction per clock cycle)
> - 指令数：某程序所需要的总指令数；
> - 公式四：CPI = CPU时钟周期数 / 程序指令总数

### 04-4  ⭐性能公式

综上所述（04-2以及04-3），CPU性能公式为：

- 公式五：CPU时间 = 指令数 × CPI × 时钟周期时间

- 公式六：CPU时间 = 指令数 × CPI / 时钟频率

  - 性能的评估取决于时间，指令多少和CPI都不能单独决定性能，公式右侧的子集都不能决定性能；

  - 下面是对于公式五的进一步分析，再具体到测量单位指标：

  - | 性能的分量    | 测量单位                     |
    | ------------- | ---------------------------- |
    | 程序的CPU时间 | 程序执行的执行时间，s        |
    | 指令数目      | 程序执行的指令数             |
    | CPI           | 每条指令平均执行的时钟周期数 |
    | 时钟周期时间  | 每个时钟周期的长度，s        |

- 公式七：CPU执行时间 = 时间 / 程序数 = 指令数 / 程序 数× 时钟周期数 / 指令数 × 时间 / 时钟周期

### 04-5  程序性能的评估

上面00-4理解程序性能中，介绍过程序性能的影响因素，现在拿上面公式中的因子再套用一下：

| 硬件或软件因素 | 影响                  | 影响方式                                                     |
| -------------- | --------------------- | ------------------------------------------------------------ |
| 算法           | 指令数，可能会影响CPI | 算法决定了源程序指令的数目，进而决定了CPU执行指令的数目。同时算法也可能影响CPI，比如使用过多除法，CPI会变大 |
| 编程语言       | 指令数，CPI           | 编程语言必然与指令数挂钩，因为要翻译为指令；影响CPI的方式比如Java支持数据抽象而进行的间接调用会使得CPI指令变大 |
| 编译程序       | 指令数，CPI           | 决定源程序到指令的翻译过程，所以编译程序的效率会影响指令和CPI两者 |
| 指令集体系结构 | 指令数，CPI，时钟频率 | 虽然具体过程还不知道，但指令集体系结构会影响这三者。⭐        |

![image-20220306162917237](C:\Users\shandaiwang\AppData\Roaming\Typora\typora-user-images\image-20220306162917237.png)

### 04-6  指令集的性能

衡量指令集的性能的方式有很多：

- 设计指标：
  - 能否被实现；
  - 多长时间；
  - 代价如何；
- 静态指标：
  - 在该指令集下程序的内存占用；
- 动态指标：
  - 对于一个程序需要执行多少指令？
  - 处理器需要多少字节的空间来执行程序？
  - 每个指令需要几个时钟周期？
- **最佳的指标是执行时间。**

### 04-7  SPEC基准 | Amdahl's law |  MIPS

#### 04-7-1  [SPEC基准](http:www.spec.org)

虽然执行时间对于性能的衡量已经很好了，但人们还是希望建立一个专门用于测量性能的尺度。

前面提到过，加速大概率事件是一种重要思想，**但哪些事件是大概率事件呢**？这也需要一个对基准测试程序集合进行**预测**。

SPEC(system performance evaluation cooperative)是由许多计算机销售商共同支持的组织，它建立了主要面向处理器性能的基准程序集：

1. 是一种对于固定程序集合执行时间的衡量手段，会基于集合里程序的运行情况给出一个评级；

   > 评级是程序运行时间经标准化处理后的几何平均数，即乘积后开平方；
   >
   > 我们知道算术平均，每个数一视同仁；几何平均指明了参数的集中趋势，中位数贡献更大；调和平均（调和不等式），倾向于序列中较小的数值。

2. 这个评级能够反映特定CPU、内存系统、I/O系统、操作系统、编译器的性能；

3. 支持对不同的计算机系统进行简单的比较；

   > 当然还有另外一些基准程序集，如PARSEC、SPLASH等

4. 此外SPEC还建立了对于功耗的基准测试程序，功能和上面相似，计算公式不同：

   评级 = Σ工作负载在每10%增量处的性能 / Σ对应的功耗和；

   > 如果是顺序看到这里，功耗在05部分；

#### 04-7-2  阿姆达尔定律

这一定律是加速大概率事件思想的量化总结。当我们对系统的某个部分加速时，其对系统的整体性能影响取决于该部分所占比例和加速的程度。

- 公式：改进后的执行时间 = 改进部分的原执行时间 / 改进程度+ 不受影响的执行时间；⭐
- 举个例子来说吧，100s的原总时长中，我们改善其中的50s，运行速度改善到原来的5倍，则现时长 = 50 / 5 + 50 = 60；
- 从例子也知道，这种优化存在一种极限，或是说，我们每次做相同程度的优化，收益在递减（再对同一部分进行一次5倍的优化，总时长变化在减小）；

我们可以使用这个定律来进行一些性能提升的预测。

#### 04-7-3  MIPS

这里的MIPS不是指令集的名字，这是一种新的性能衡量方法，跟前面所有以时间度量的方法不同。

MIPS(million instruction per second，每秒百万条指令)：

- 公式：MIPS = 指令数 / （执行时间 × 10<sup>6</sup>)
- 表示指令执行的速率，规定性能与时间成反比，那么高MIPS值的计算机就越快，这符合直觉。
- 但是这也有问题，很明显，指令之间并不相同。
  - 不同指令集的计算机不能比较。
  - 就算在同一计算机上，对于不同的程序也会有不同的MIPS值。
  - 有些指令的执行速度快于另一些，这也可能导致MIPS值大小与真正性能好坏的差距。

## 05  能耗 | 功耗

### 05-1  计算

几个公式：

1. 能耗由两部分组成：动态能耗和静态能耗；

   静态能耗是由泄漏电流造成的，顾名思义它在晶体管不工作时也会产生。

2. 动态能耗 = k × 负载电容 × 电压²

   动态能耗是晶体管状态翻转过程产生的能耗，0-1-0或是1-0-1

3. 一个晶体管动态能耗 = 0.5 × k × 负载电容 × 电压²

4. 一个晶体管动态功耗 = 0.5 × 负载电容 × 电压² × 开关频率

   开关频率由时钟频率决定

   负载电容是导线和晶体管的总电容

5. 相对功耗 = P<sub>新</sub> / P<sub>旧</sub>

由上式我们可以理解，时钟频率增长1000倍，功耗只增长30倍。，是因为每次工艺更新时钟频率上升时，设计者都会考虑使电压都会降低。

**面向性能的设计**和**面向能量效率的设计**有些目标是重合的。举个例子：

> 1GHz的处理器原本100s的运行总时长，70W用于动态能耗，30W静态能耗，现在升为1.2GHz，请问能耗怎么变化？
>
> 答：降低。
>
> 现能量 = (70 × 1.2 + 30) × 100 / 1.2 = 9500J；
>
> 原能量 = 100W × 100s = 10000J.

目前功耗达到了一个瓶颈。

### 05-2  [两者的区别](https://www.zhihu.com/question/268707643/answer/443117988)

- 功耗(Power)，功率的损耗，在单位时间中所消耗的能源的数量，单位为 W；
- 能耗(Energy)，能源转换实物量的损耗，单位是焦耳/秒。在后 PC 时代，能源是真正的资源更需要关注。
- 例如 WSC，关注的不仅仅是耗电功率（功耗），而是由于高温带来的昂贵冷却费用。因此在评价功耗时，使用能耗比功耗更加合理。

## 06  简单总结 | Review

在文章最后，我希望能够总结一下前面大致说了点什么，留下一些宏观的印象，以便于后续的进行。

1. 计算机组成与体系结构的一些基础概念和名词，弥补一点大学计算机基础没有学习的缺漏，增加一点专业素养；
2. 重讲了一下程序的概念，不过较于之前那一篇，这次更加注重转换过程，而不是编译链；
3. 计算机重要的组成硬件与冯·诺伊曼结构；
4. 指令级体系结构等抽象思想；
5. 性能的评估方式，我们可以以此照着店家说明书来比对电脑的性能；
6. 能耗和功耗，这是性能之外的考虑。

