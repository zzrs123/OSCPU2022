# ps2

## 1. ps2_keyboard.v

首先最难理解的就是sampling的计算方式。

### 1.1 sampling

`s2_clk_sync`中的第二位（即 `ps2_clk_sync[1]`）表示时钟信号在上一个时钟周期中的状态。在PS/2协议中，数据传输是在时钟下降沿进行的，因此当 `ps2_clk_sync[1] = 1`时，表示从上个时钟周期到当前时钟周期之间出现了下降沿，即 `ps2_clk_sync`记录了下降沿的发生。

另外，值得一提的是，当 `ps2_clk_sync`寄存器的值为 `001` 时，表示时钟在上一个时钟周期是高电平，当前周期是下降沿，因此我们可以在这个时候进行数据的采样和处理。这也是PS/2协议中采样的**唯一时刻。**

**也就是sync信号的1记录的是下降沿的发生**

### 1.2 ready

`ready` 的值由以下两个条件决定：

1. 进行输出数据操作时，只有FIFO队列中有数据（即 `w_ptr > r_ptr`）时，`ready` 才置为1。
2. 在输出完一条数据后，如果FIFO队列中还有其他数据时间，`ready` 将保持1，直到FIFO队列为空时，将置为0。

### 1.3 nextdata_n

`nextdata_n`用于控制下一个数据位的读取。如果 `nextdata_n`的值为0，则表示需要读取下一个数据位。如果 `nextdata_n`的值为1，则表示不需要进行下一个数据位的读取，并继续输出当前的数据位。

只有在 `ready = 1`时，才会进行 `nextdata_n`表示的下一个数据位的读取。

### 1.x 整理

看了看。这个代码里就是三个部分：ps2时序逻辑约束、缓冲区读逻辑、缓冲区写逻辑。

#### A. 时序约束

主要是sampling。

#### B. 读逻辑

读逻辑在代码中的实现方式如下：

1. 当FIFO队列非空（`w_ptr > r_ptr`）且 `ready`信号为1时，从地址为 `r_ptr` 的位置读取数据输出，并将 `r_ptr`指向下一个位置。
2. 如果地址为 `r_ptr` 的数据被读完后，将使 `ready` 信号置为0

#### C. 写逻辑

写逻辑在代码中的实现方式如下：

1. 每当从PS/2设备读取了一个完整的数据包并通过检验后，将包含扫描码的数据存储在FIFO队列的 `w_ptr` 位置，并更新 `w_ptr` 指向缓冲区的下一个位置。
2. 在写入数据时，会检查队列是否已满。如果队列已满，则置 `overflow` 信号为1，表示溢出。


w_ptr和r_ptr分别指向数据队列fifo中可用于读取的下一个位置和可用于写入的下一个位置。

* 具体来说，当接收到11个比特位，并且这些比特位符合预期时，这些比特位被存储在长度为11的数组中。
* 然后，这些位被存储在buffer中，并在count变量达到10时转移至队列fifo。
* 在转移期间，将11位数据放在fifo_list[w_ptr]所指示的位置。
* 因此，下一次从队列fifo中读取元素时，将从fifo_list[r_ptr]所指示的位置开始。
* 因此，读取指针r_ptr和写入指针w_ptr是相互依存的。当r_ptr指向的部分的数据被读取时，它将移动到下一个可读取的位置，w_ptr将在适当的时候将新的数据写入队列fifo。
* 当队列fifo已满时，w_ptr将不再向队列中写入新数据。
* 相反，当队列的最后一个空间被写入数据时，w_ptr将被循环回起始位置，因此，当队列被读取到尾部并达到最大容量时，将绕回队列开头，如果这时队列未被读取完，则fifo_overflow端口将置1以表示队列溢出。
*
